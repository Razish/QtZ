/*
===========================================================================
Copyright (C) 1999-2005 Id Software, Inc.

This file is part of Quake III Arena source code.

Quake III Arena source code is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the License,
or (at your option) any later version.

Quake III Arena source code is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Quake III Arena source code; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
===========================================================================
*/
//
// g_local.h -- local definitions for game module

#pragma once

#include "../qcommon/q_shared.h"
#include "bg_public.h"
#include "g_public.h"

// the "gameversion" client command will print this plus compile date
#define	GAMEVERSION	BASEGAME

#define BODY_QUEUE_SIZE		8

#define INFINITE			1000000

//#define	FRAMETIME			100					// msec
#define	CARNAGE_REWARD_TIME	3000
#define REWARD_SPRITE_TIME	2000

#define	INTERMISSION_DELAY_TIME	1000

// gentity->flags
#define	FL_GODMODE				0x0001
#define	FL_NOTARGET				0x0002
#define	FL_TEAMSLAVE			0x0004	// not the first on the team
#define FL_NO_KNOCKBACK			0x0008
#define FL_DROPPED_ITEM			0x0010
#define FL_NO_BOTS				0x0020	// spawn point not for bot use
#define FL_NO_HUMANS			0x0040	// spawn point just for bots
#define FL_FORCE_GESTURE		0x0080	// force gesture on client
#define	FL_BOUNCE				0x0100	// for missiles
#define	FL_BOUNCE_HALF			0x0200	// for missiles
#define	FL_BOUNCE_SHRAPNEL		0x0400	// special shrapnel flag

// movers are things like doors, plats, buttons, etc
typedef enum moverState_e {
	MOVER_POS1=0,
	MOVER_POS2,
	MOVER_1TO2,
	MOVER_2TO1
} moverState_t;

#define SP_PODIUM_MODEL		"models/mapobjects/podium/podium4.md3"

typedef enum hitLocation_e {
	HL_NONE=0,
	HL_FOOT_RT,
	HL_FOOT_LT,
	HL_LEG_RT,
	HL_LEG_LT,
	HL_WAIST,
	HL_BACK_RT,
	HL_BACK_LT,
	HL_BACK,
	HL_CHEST_RT,
	HL_CHEST_LT,
	HL_CHEST,
	HL_ARM_RT,
	HL_ARM_LT,
	HL_HAND_RT,
	HL_HAND_LT,
	HL_HEAD,
	HL_GENERIC1,
	HL_GENERIC2,
	HL_GENERIC3,
	HL_GENERIC4,
	HL_GENERIC5,
	HL_GENERIC6,
	HL_MAX
} hitLocation_t;

typedef struct gentity_s gentity_t;
typedef struct gclient_s gclient_t;

#include "g_unlagged.h"

struct gentity_s {
	entityState_t	s;	// communicated by server to clients
	entityShared_t	r;	// shared by both the server system and game

	// DO NOT MODIFY ANYTHING ABOVE THIS
	//	THE SERVER EXPECTS THE FIELDS IN THAT ORDER!

	// house-keeping
	qboolean			inuse;
	const char			*classname;
	qboolean			neverFree;	// if true, FreeEntity will only unlink. bodyque uses this
	int					freetime;	// level.time when the object was freed
	int					eventTime;	// events will be cleared EVENT_VALID_MSEC after set
	qboolean			freeAfterEvent;
	qboolean			unlinkAfterEvent;
	struct gclient_s	*client;	// NULL if not a client

	// generic entity info
	int			spawnflags;
	int			flags;				// FL_* variables
	char		*model, *model2;	// non-player entities render this model
	qboolean	physicsObject;		// if true, it can be pushed by movers and fall off edges. all game items are physicsObjects.
	float		physicsBounce;		// 1.0 = continuous bounce, 0.0 = no bounce
	int			clipmask;			// brushes with this content value will be collided against when moving. items and corpses do not collide against players, for instance
	char		*target, *targetname;
	char		*team;

	// damageable entities
	int			health;
	qboolean	takedamage;

	// thinking
	int		nextthink; // level.time the next think() will occur
	void	(*think)	( gentity_t *self );
	void	(*reached)	( gentity_t *self ); // movers call this when hitting endpoint
	void	(*blocked)	( gentity_t *self, gentity_t *other );
	void	(*touch)	( gentity_t *self, gentity_t *other, trace_t *trace );
	void	(*use)		( gentity_t *self, gentity_t *other, gentity_t *activator );
	void	(*pain)		( gentity_t *self, gentity_t *attacker, int damage );
	void	(*die)		( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );

	// target_print
	// target_location
	char	*message;

	// missiles
	// movers
	gentity_t	*parent;

	// movers
	moverState_t	moverState;
	int				soundPos1, sound1to2, soundPos2, sound2to1;
	int				soundLoop;
	gentity_t		*nextTrain, *prevTrain;
	vector3			pos1, pos2;

	// trigger_hurt
	// bodyqueue
	int		timestamp;

	gentity_t	*target_ent;
	float		speed;
	vector3		movedir;

	int			painDebounceTime;
	int			flySoundDebounceTime; // wind tunnel
	int			lastMoveTime;

	// missiles
	int		damage, splashDamage;
	int		splashRadius;
	int		methodOfDeath, splashMethodOfDeath;
	int		bounceCount;
	int		dflags;
	float	knockbackMulti, knockbackMultiSelf;
	float	knockbackDampVert; //special multiplier for dflags & DAMAGE_VERTICAL_KNOCKBACK

	int			count;
	gentity_t	*enemy;
	
	// movers?
	gentity_t	*chain;
	gentity_t	*activator;
	gentity_t	*teamchain; // next entity in team
	gentity_t	*teammaster; // master of the team

	int				watertype;
	int				waterlevel;
	int				noiseIndex;
	float			wait;
	float			random;
	const gitem_t	*item; // for bonus items
	int				genericValue1; // for flags, will contain the time (in accurate ms) it has been held for speed caps
	int				genericValue2; // for flags, the lowest 5 bits will refer to the clientNum who dropped it if the 6th bit is set. the remaining bits will contain the level.time it was dropped
};

typedef enum clientConnected_e {
	CON_DISCONNECTED,
	CON_CONNECTING,
	CON_CONNECTED
} clientConnected_t;

typedef enum spectatorState_e {
	SPECTATOR_NOT,
	SPECTATOR_FREE,
	SPECTATOR_FOLLOW,
	SPECTATOR_SCOREBOARD
} spectatorState_t;

typedef enum playerTeamStateState_e {
	TEAM_BEGIN,		// Beginning a team game, spawn at base
	TEAM_ACTIVE		// Now actively playing
} playerTeamStateState_t;

typedef struct playerTeamState_s {
	playerTeamStateState_t	state;

	int			location;

	int			captures;
	int			basedefense;
	int			carrierdefense;
	int			flagrecovery;
	int			fragcarrier;
	int			assists;

	float		lasthurtcarrier;
	float		lastreturnedflag;
	float		flagsince;
	float		lastfraggedcarrier;
} playerTeamState_t;

// client data that stays across multiple levels or tournament restarts
// this is achieved by writing all the data to cvar strings at game shutdown
// time and reading them back at connection time.  Anything added here
// MUST be dealt with in G_InitSessionData() / G_ReadSessionData() / G_WriteSessionData()
typedef struct clientSession_s {
	team_t				sessionTeam;
	int					spectatorNum;		// for determining next-in-line to play
	spectatorState_t	spectatorState;
	int					spectatorClient;	// for chasecam and follow mode
} clientSession_t;

#define GF_VOTED	0x0001

#define	MAX_VOTE_COUNT		3

// client data that stays across multiple respawns, but is cleared
// on each level change or team change at ClientBegin()
typedef struct clientPersistant_s {
	clientConnected_t	connected;	
	usercmd_t			cmd;					// we would lose angles if not persistent
	qboolean			localClient;			// true if "ip" info key is "localhost"
	qboolean			initialSpawn;			// the first spawn should be at a cool location
	qboolean			predictItemPickup;		// based on cg_predictItems userinfo
	char				netname[MAX_NETNAME];
	int					enterTime;				// level.time the client entered the game
	playerTeamState_t	teamState;				// status in teamplay games
	qboolean			ready;
	int					vote;					// 0 = none, 1 = yes, 2 = no
} clientPersistant_t;


// this structure is cleared on each ClientSpawn(),
// except for 'client->pers' and 'client->sess'
struct gclient_s {
	// ps MUST be the first element, because the server expects it
	playerState_t	ps;				// communicated by server to clients

	// the rest of the structure is private to game
	clientPersistant_t	pers;
	clientSession_t		sess;

	qboolean	readyToExit;		// wishes to leave the intermission

	qboolean	noclip;

	int			lastCmdTime;		// level.time of last usercmd_t, for EF_CONNECTION
									// we can't just use pers.lastCommand.time, because
									// of the g_sycronousclients case
	int			buttons;
	int			oldbuttons;
	int			latched_buttons;

	vector3		oldOrigin;

	// sum up damage over an entire frame, so
	// shotgun blasts give a single big kick
	int			damage_armor;		// damage absorbed by armor
	int			damage_blood;		// damage taken out of health
	int			damage_knockback;	// impact damage
	vector3		damage_from;		// origin for vector calculation
	qboolean	damage_fromWorld;	// if true, don't use the damage_from vector

	int			accurateCount;		// for "impressive" reward sound

	int			accuracy_shots;		// total number of shots
	int			accuracy_hits;		// total number of hits

	//
	int			lastkilled_client;	// last client that this client killed
	int			lasthurt_client;	// last client that damaged this client
	int			lasthurt_mod;		// type of damage the client did

	// timers
	int			respawnTime;		// can respawn when time > this, force after g_forcerespwan
	int			inactivityTime;		// kick players when time > this
	qboolean	inactivityWarning;	// qtrue if the five seoond warning has been given
	int			rewardTime;			// clear the EF_AWARD_IMPRESSIVE, etc when time > this

	int			airOutTime;

	int			lastKillTime;		// for multiple kill rewards

	qboolean	fireHeld;			// used for hook
	gentity_t	*hook;				// grapple hook if out

	int			switchTeamTime;		// time the player switched teams

	// timeResidual is used to handle events that happen every second
	// like health / armor countdowns and regeneration
	int			timeResidual;

	gentity_t	*persistentPowerup;

	char		*areabits;

	//NT - client origin trails
	struct {
		int				trailHead;
		clientTrail_t	trail[NUM_CLIENT_TRAILS];
		clientTrail_t	saved; // used to restore after time shift
	} unlagged;

	struct {
		int			headshotCount;
		int			airshotCount;
		int			amazingCount;
	} tracking;

	int			gameFlags; // voted, etc
	int			lastScoresTime; // level.time the last scoreboard message was went
	qboolean	scoresWaiting;
};


//
// this structure is cleared as each map is entered
//
#define	MAX_SPAWN_VARS			64
#define	MAX_SPAWN_VARS_CHARS	4096

typedef struct level_locals_s {
	struct gclient_s	*clients;		// [maxclients]

	struct gentity_s	*gentities;
	int					gentitySize;
	int					num_entities;		// MAX_CLIENTS <= num_entities <= ENTITYNUM_MAX_NORMAL

	int					warmupTime;			// restart match at this time

	fileHandle_t		logFile;

	// store latched cvars here that we want to get at often
	int					maxclients;

	int					framenum;
	int					time;					// in msec
	int					previousTime;			// so movers can back up when blocked

	int					startTime;				// level.time the map was started

	int					teamScores[TEAM_NUM_TEAMS];
	int					lastTeamLocationTime;		// last time of client team location update

	qboolean			newSession;				// don't use any old session data, because
										// we changed gametype

	qboolean			restarted;				// waiting for a map_restart to fire

	int					numConnectedClients;
	int					numNonSpectatorClients;	// includes connecting clients
	int					numPlayingClients;		// connected, non-spectators
	int					sortedClients[MAX_CLIENTS];		// sorted by score
	int					follow1, follow2;		// clientNums for auto-follow spectators

	int					snd_fry;				// sound index for standing in lava

	int					warmupModificationCount;	// for detecting if g_warmup is changed

	// voting state
	char				voteString[MAX_STRING_CHARS];
	char				voteStringClean[MAX_STRING_CHARS];
	char				voteDisplayString[MAX_STRING_CHARS];
	int					voteTime;				// level.time vote was called
	int					voteExecuteTime;		// time the vote is executed
	int					voteExecuteDelay;		// set per-vote
	int					voteYes;
	int					voteNo;
	qboolean			votePoll;
	int					numVotingClients;		// set by CalculateRanks

	qboolean			votingGametype;
	int					votingGametypeTo;

	// spawn variables
	qboolean			spawning;				// the G_Spawn*() functions are valid
	int					numSpawnVars;
	char				*spawnVars[MAX_SPAWN_VARS][2];	// key / value pairs
	size_t				numSpawnVarChars;
	char				spawnVarChars[MAX_SPAWN_VARS_CHARS];

	// intermission state
	int					intermissionQueued;		// intermission was qualified, but
										// wait INTERMISSION_DELAY_TIME before
										// actually going there so the last
										// frag can be watched.  Disable future
										// kills during this delay
	int					intermissiontime;		// time the intermission was started
	char				*changemap;
	qboolean			readyToExit;			// at least one client wants to exit
	int					exitTime;
	vector3				intermission_origin;	// also used for spectator spawns
	vector3				intermission_angle;

	qboolean			locationLinked;			// target_locations get linked
	gentity_t			*locationHead;			// head of the location list
	int					bodyQueIndex;			// dead bodies
	gentity_t			*bodyQue[BODY_QUEUE_SIZE];
	int					portalSequence;

	//QtZ: Added
	int					frameStartTime;         //NT - actual time frame started

	gametype_t			gametype;
	qboolean			allReady;
	char				rawmapname[MAX_QPATH];

	struct {
		int					state;		//OSP: paused state of the match
		int					time;
	} pause;

	struct {
		int					num;
		char				*infos[MAX_ARENAS];
	} arenas;
} level_locals_t;


//
// g_spawn.c
//
qboolean	G_SpawnString( const char *key, const char *defaultString, char **out );
// spawn string returns a temporary reference, you must CopyString() if you want to keep it
qboolean	G_SpawnFloat( const char *key, const char *defaultString, float *out );
qboolean	G_SpawnInt( const char *key, const char *defaultString, int *out );
qboolean	G_SpawnVector( const char *key, const char *defaultString, vector3 *out );
void		G_SpawnEntitiesFromString( void );
char *G_NewString( const char *string );

//
// g_cmds.c
//
void StopFollowing( gentity_t *ent );
void BroadcastTeamChange( gclient_t *client, int oldTeam );
void SetTeam( gentity_t *ent, char *s );
void Cmd_FollowNext_f( gentity_t *ent );
void Cmd_FollowPrev_f( gentity_t *ent );

//
// g_items.c
//
void G_CheckTeamItems( void );
void G_RunItem( gentity_t *ent );
void RespawnItem( gentity_t *ent );

void UseHoldableItem( gentity_t *ent );
void PrecacheItem (const gitem_t *it);
gentity_t *Drop_Item( gentity_t *ent, const gitem_t *item, float angle );
gentity_t *LaunchItem( const gitem_t *item, vector3 *origin, vector3 *velocity );
void SetRespawn (gentity_t *ent, float delay);
void G_SpawnItem (gentity_t *ent, const gitem_t *item);
void FinishSpawningItem( gentity_t *ent );
void Think_Weapon (gentity_t *ent);
int ArmorIndex (gentity_t *ent);
void	Add_Ammo (gentity_t *ent, int weapon, int count);
void Touch_Item (gentity_t *ent, gentity_t *other, trace_t *trace);

void ClearRegisteredItems( void );
void RegisterItem( const gitem_t *item );
void SaveRegisteredItems( void );

//
// g_utils.c
//
int G_ModelIndex( char *name );
int		G_SoundIndex( char *name );
void	G_TeamCommand( team_t team, const char *cmd );
void	G_KillBox (gentity_t *ent);
gentity_t *G_Find (gentity_t *from, int fieldofs, const char *match);
gentity_t *G_PickTarget (char *targetname);
void	G_UseTargets (gentity_t *ent, gentity_t *activator);
void	G_SetMovedir ( vector3 *angles, vector3 *movedir);

void	G_InitGentity( gentity_t *e );
gentity_t	*G_Spawn( void );
gentity_t *G_TempEntity( vector3 *origin, int event );
void	G_Sound( gentity_t *ent, int channel, int soundIndex );
void	G_FreeEntity( gentity_t *e );
qboolean	G_EntitiesFree( void );

void	G_TouchTriggers (gentity_t *ent);

float vectoyaw( const vector3 *vec );

void G_AddPredictableEvent( gentity_t *ent, int event, int eventParm );
void G_AddEvent( gentity_t *ent, int event, int eventParm );
void G_SetOrigin( gentity_t *ent, vector3 *origin );

//
// g_combat.c
//
qboolean CanDamage (gentity_t *targ, vector3 *origin);
void G_Damage( gentity_t *real_targ, gentity_t *real_inflictor, gentity_t *real_attacker, gentity_t *real_affector, vector3 *real_dir, vector3 *real_point, int real_damage, int real_dflags, int real_mod );
qboolean G_RadiusDamage( vector3 *origin, gentity_t *attacker, float damage, float radius, gentity_t *ignore, gentity_t *missile, int mod );
int G_InvulnerabilityEffect( gentity_t *targ, vector3 *dir, vector3 *point, vector3 *impactpoint, vector3 *bouncedir );
void body_die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int meansOfDeath );
void TossClientItems( gentity_t *self );
void TossClientPersistantPowerups( gentity_t *self );
void TossClientCubes( gentity_t *self );
int G_GetHitLocation(gentity_t *target, vector3 *ppoint);

// damage flags
#define DAMAGE_NORMAL				0x00000000
#define DAMAGE_RADIUS				0x00000001	// damage was indirect
#define DAMAGE_NO_ARMOR				0x00000002	// armour does not protect from this damage
#define DAMAGE_NO_KNOCKBACK			0x00000004	// do not affect velocity, just view angles
#define DAMAGE_NO_PROTECTION		0x00000008  // armor, shields, invulnerability, and godmode have no effect
#define DAMAGE_NO_TEAM_PROTECTION	0x00000010  // armor, shields, invulnerability, and godmode have no effect
#define DAMAGE_VERTICAL_KNOCKBACK	0x00000020	// x/y knockback will be dampened by missile->knockbackDampVert

//
// g_missile.c
//
void G_RunMissile( gentity_t *ent );
void G_ExplodeMissile( gentity_t *ent );
gentity_t *CreateMissile( vector3 *org, vector3 *dir, float vel, int life, gentity_t *owner);

//
// g_mover.c
//
void G_RunMover( gentity_t *ent );
void Touch_DoorTrigger( gentity_t *ent, gentity_t *other, trace_t *trace );

//
// g_trigger.c
//
void trigger_teleporter_touch (gentity_t *self, gentity_t *other, trace_t *trace );


//
// g_misc.c
//
void TeleportPlayer( gentity_t *player, vector3 *origin, vector3 *angles );
void TeleportPlayerSeamless( gentity_t *player, vector3 *origin, vector3 *angles );
void DropPortalSource( gentity_t *ent );
void DropPortalDestination( gentity_t *ent );


//
// g_weapon.c
//
qboolean LogAccuracyHit( gentity_t *target, gentity_t *attacker );
void CalcMuzzlePoint ( gentity_t *ent, vector3 *forward, vector3 *right, vector3 *up, vector3 *muzzlePoint );



//
// g_client.c
//
int TeamCount( int ignoreClientNum, team_t team );
team_t PickTeam( int ignoreClientNum );
void SetClientViewAngle( gentity_t *ent, vector3 *angle );
gentity_t *SelectSpawnPoint (vector3 *avoidPoint, vector3 *origin, vector3 *angles, qboolean isbot);
void CopyToBodyQue( gentity_t *ent );
void ClientRespawn(gentity_t *ent);
void BeginIntermission( void );
void InitBodyQue( void );
void ClientSpawn( gentity_t *ent );
void player_die (gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod);
void AddScore( gentity_t *ent, vector3 *origin, int score );
void CalculateRanks( void );
qboolean SpotWouldTelefrag( gentity_t *spot );
void G_ClearVote( gentity_t *ent );

//
// g_svcmds.c
//
qboolean ConsoleCommand( void );
void G_ProcessIPBans( void );
qboolean G_FilterPacket (char *from);

//
// g_weapon.c
//
void FireWeapon( gentity_t *ent, int special );

//
// g_main.c
//
void G_InitGame( int levelTime, int randomSeed, qboolean restart );
void G_RunFrame( int levelTime );
void G_ShutdownGame( qboolean restart );
void CheckExitRules( void );
void MoveClientToIntermission( gentity_t *ent );
void FindIntermissionPoint( void );
void G_RunThink (gentity_t *ent);
void AddTournamentQueue(gclient_t *client);
void QDECL G_LogPrintf( const char *fmt, ... ) __attribute__ ((format (printf, 1, 2)));
void SendScoreboardMessageToAllClients( void );

//
// g_client.c
//
char *ClientConnect( int clientNum, qboolean firstTime, qboolean isBot );
void ClientUserinfoChanged( int clientNum );
void ClientDisconnect( int clientNum );
void ClientBegin( int clientNum );
void ClientCommand( int clientNum );

//
// g_active.c
//
void ClientThink( int clientNum );
void ClientEndFrame( gentity_t *ent );
void G_RunClient( gentity_t *ent );

//
// g_team.c
//
qboolean OnSameTeam( gentity_t *ent1, gentity_t *ent2 );
void Team_CheckDroppedItem( gentity_t *dropped );

//
// g_mem.c
//
void *G_Alloc( size_t size );
void G_InitMemory( void );
void Svcmd_GameMem_f( void );

//
// g_session.c
//
void G_ReadSessionData( gclient_t *client );
void G_InitSessionData( gclient_t *client, char *userinfo );

void G_InitWorldSession( void );
void G_WriteSessionData( void );

//
// g_arenas.c
//
void UpdateTournamentInfo( void );
void SpawnModelsOnVictoryPads( void );

//
// g_bot.c
//
void G_LoadArenas( void );
const char *G_RefreshNextMap( int gametype );
qboolean G_DoesMapSupportGametype( const char *mapname, int gametype );
void G_InitBots( void );
char *G_GetBotInfoByNumber( int num );
char *G_GetBotInfoByName( const char *name );
void G_CheckBotSpawn( void );
void G_RemoveQueuedBotBegin( int clientNum );
qboolean G_BotConnect( int clientNum, qboolean restart );
void Svcmd_AddBot_f( void );
void Svcmd_BotList_f( void );
void BotInterbreedEndMatch( void );

// ai_main.c
#define MAX_FILEPATH			144

//bot settings
typedef struct bot_settings_s
{
	char characterfile[MAX_FILEPATH];
	float skill;
	char team[MAX_FILEPATH];
} bot_settings_t;

int BotAISetup( int restart );
int BotAIShutdown( int restart );
int BotAILoadMap( int restart );
int BotAISetupClient(int client, struct bot_settings_s *settings, qboolean restart);
int BotAIShutdownClient( int client, qboolean restart );
int BotAIStartFrame( int time );
void BotTestAAS(vector3 *origin);

#include "g_team.h" // teamplay specific stuff


extern	level_locals_t	level;
extern	gentity_t		g_entities[MAX_GENTITIES];

#define	FOFS(x) ((size_t)&(((gentity_t *)0)->x))

//OSP: pause
typedef enum matchPause_e {
	PAUSE_NONE=0,		// Match is NOT paused.
	PAUSE_PAUSED,		// Match is paused, counting down
	PAUSE_UNPAUSING,	// Pause is about to expire
} matchPause_t;

#define XCVAR_PROTO
	#include "g_xcvar.h"
#undef XCVAR_PROTO

extern gameImport_t *trap;
